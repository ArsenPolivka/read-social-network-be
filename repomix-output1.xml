This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
prisma/
  schema.prisma
src/
  ai/
    dto/
      create-ai.dto.ts
      update-ai.dto.ts
    entities/
      ai.entity.ts
    ai.controller.spec.ts
    ai.controller.ts
    ai.module.ts
    ai.service.spec.ts
    ollama.service.ts
    rag.service.ts
  auth/
    auth.module.ts
    supabase.strategy.ts
  books/
    books.controller.ts
    books.service.ts
  bookshelf/
    bookshelf.controller.ts
    bookshelf.module.ts
    bookshelf.service.ts
  ingestion/
    dto/
      create-ingestion.dto.ts
      update-ingestion.dto.ts
    entities/
      ingestion.entity.ts
    ingestion.controller.spec.ts
    ingestion.controller.ts
    ingestion.module.ts
    ingestion.processor.ts
    ingestion.service.spec.ts
    ingestion.service.ts
  prisma/
    dto/
      create-prisma.dto.ts
      update-prisma.dto.ts
    entities/
      prisma.entity.ts
    prisma.controller.spec.ts
    prisma.controller.ts
    prisma.module.ts
    prisma.service.spec.ts
    prisma.service.ts
  profile/
    profile.controller.ts
    profile.module.ts
    profile.service.ts
  social/
    social.controller.ts
    social.module.ts
    social.service.ts
  tracker/
    tracker.controller.ts
    tracker.module.ts
    tracker.service.ts
  types/
    pdf-parse.d.ts
  app.controller.spec.ts
  app.controller.ts
  app.module.ts
  app.service.ts
  main.ts
test/
  app.e2e-spec.ts
  jest-e2e.json
.gitignore
.prettierrc
eslint.config.mjs
nest-cli.json
package.json
prisma.config.ts
README.md
repomix-output1.xml
tsconfig.build.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="prisma/schema.prisma">
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions", "driverAdapters"]
}

datasource db {
  provider   = "postgresql"
  extensions = [vector]
}

// --- MODULE A: SOCIAL PLATFORM ---

model Profile {
  id        String   @id @default(uuid())
  userId    String   @unique @map("user_id") // Links to Supabase Auth.users.id
  username  String   @unique
  fullName  String?  @map("full_name")
  bio       String?
  avatarUrl String?  @map("avatar_url")
  onboarded Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  readingGoal    ReadingGoal?
  bookshelfItems BookshelfItem[]
  reviews        Review[]
  sessions       ReadingSession[]
  
  // Follow System
  followedBy     UserFollow[] @relation("following")
  following      UserFollow[] @relation("follower")

  // AI Module
  uploadedBooks  UploadedBook[]

  @@map("profiles")
}

model ReadingGoal {
  id        Int       @id @default(autoincrement())
  profileId String    @unique @map("profile_id")
  type      String    // 'BOOKS_PER_YEAR', 'MINUTES_PER_DAY'
  value     Int
  startDate DateTime  @default(now()) @map("start_date")
  endDate   DateTime? @map("end_date")

  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@map("reading_goals")
}

model Book {
  id            String   @id @default(cuid())
  googleBookId  String?  @unique @map("google_book_id") // Make sure this is optional (?)
  title         String
  author        String
  description   String?  @db.Text  // <--- CHANGED FROM synopsis
  coverUrl      String?  @map("cover_url")
  isbn          String?
  pageCount     Int      @default(0) @map("page_count")
  publishedYear Int?     @map("published_year")
  genres        String[]
  
  // Relations
  shelvedBy BookshelfItem[]
  reviews   Review[]
  sessions  ReadingSession[]

  @@map("books")
}

enum ShelfStatus {
  WANT_TO_READ
  READING
  READ
}

model BookshelfItem {
  id        String      @id @default(cuid())
  profileId String      @map("profile_id")
  bookId    String      @map("book_id")
  status    ShelfStatus
  progress  Int         @default(0) // Current page
  rating    Int?        
  startedAt DateTime?   @map("started_at")
  finishedAt DateTime?  @map("finished_at")
  updatedAt DateTime    @updatedAt

  profile      Profile       @relation(fields: [profileId], references: [id], onDelete: Cascade)
  book         Book          @relation(fields: [bookId], references: [id])

  @@unique([profileId, bookId])
  @@map("bookshelf_items")
}

model ReadingSession {
  id          String   @id @default(cuid())
  profileId   String   @map("profile_id")
  bookId      String   @map("book_id")
  startTime   DateTime @map("start_time")
  endTime     DateTime @map("end_time")
  durationMin Int      @map("duration_minutes")
  pagesRead   Int      @map("pages_read")

  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  book    Book    @relation(fields: [bookId], references: [id])

  @@map("reading_sessions")
}

model Review {
  id        String   @id @default(cuid())
  profileId String   @map("profile_id")
  bookId    String   @map("book_id")
  rating    Int
  content   String?  @db.Text
  createdAt DateTime @default(now()) @map("created_at")

  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  book    Book    @relation(fields: [bookId], references: [id])

  @@map("reviews")
}

model UserFollow {
  followerId  String @map("follower_id")
  followingId String @map("following_id")

  follower  Profile @relation("follower", fields: [followerId], references: [id])
  following Profile @relation("following", fields: [followingId], references: [id])

  @@id([followerId, followingId])
  @@map("user_follows")
}

// --- MODULE B: AI ENGINE ---

model UploadedBook {
  id        String   @id @default(cuid())
  profileId String   @map("profile_id")
  filePath  String   @map("file_path") // Path in Supabase Storage
  title     String
  status    String   @default("PENDING") // PENDING, PROCESSING, READY, ERROR
  createdAt DateTime @default(now()) @map("created_at")

  profile Profile     @relation(fields: [profileId], references: [id], onDelete: Cascade)
  chunks  BookChunk[]

  @@map("uploaded_books")
}

model BookChunk {
  id             String                 @id @default(cuid())
  uploadedBookId String                 @map("uploaded_book_id")
  content        String                 @db.Text
  metadata       Json?                  
  
  // This is the magic. Supabase pgvector stores the embedding here.
  // 384 dimensions matches the 'all-minilm' model (very fast/cheap).
  embedding      Unsupported("vector(384)")? 

  uploadedBook UploadedBook @relation(fields: [uploadedBookId], references: [id], onDelete: Cascade)

  @@map("book_chunks")
}
</file>

<file path="src/ai/dto/create-ai.dto.ts">
export class CreateAiDto {}
</file>

<file path="src/ai/dto/update-ai.dto.ts">
import { PartialType } from '@nestjs/mapped-types';
import { CreateAiDto } from './create-ai.dto';

export class UpdateAiDto extends PartialType(CreateAiDto) {}
</file>

<file path="src/ai/entities/ai.entity.ts">
export class Ai {}
</file>

<file path="src/ai/ai.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { AiController } from './ai.controller';
import { AiService } from './ollama.service';

describe('AiController', () => {
  let controller: AiController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AiController],
      providers: [AiService],
    }).compile();

    controller = module.get<AiController>(AiController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/ai/ai.controller.ts">
import { Controller, Post, Body, UseGuards } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { RagService } from './rag.service';

@Controller('ai')
@UseGuards(AuthGuard('jwt'))
export class AiController {
  constructor(private readonly ragService: RagService) {}

  @Post('ask')
  async askQuestion(@Body() body: { bookId: string; question: string }) {
    // bookId here refers to the UploadedBook.id (from the ingestion table)
    return this.ragService.askQuestion(body.bookId, body.question);
  }
}
</file>

<file path="src/ai/ai.module.ts">
import { Module } from '@nestjs/common';
import { OllamaService } from './ollama.service';
import { RagService } from './rag.service';
import { AiController } from './ai.controller'; // Added
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [AiController], // Added
  providers: [OllamaService, RagService],
  exports: [OllamaService, RagService],
})
export class AiModule {}
</file>

<file path="src/ai/ai.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { AiService } from './ollama.service';

describe('AiService', () => {
  let service: AiService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [AiService],
    }).compile();

    service = module.get<AiService>(AiService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/ai/ollama.service.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';

@Injectable()
export class OllamaService {
  private ollamaHost = process.env.OLLAMA_HOST || 'http://127.0.0.1:11434';

  // 1. Generate Embeddings (for Ingestion)
  async generateEmbedding(text: string): Promise<number[]> {
    try {
      const response = await fetch(`${this.ollamaHost}/api/embeddings`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model: 'all-minilm', // Must run: ollama pull all-minilm
          prompt: text,
        }),
      });
      const data = await response.json();
      return data.embedding;
    } catch (error) {
      console.error('Embedding failed. Is Ollama running?', error);
      throw new InternalServerErrorException('Ollama connection failed');
    }
  }

  // 2. Chat Completion (for RAG)
  async chat(prompt: string, context: string): Promise<any> {
    const response = await fetch(`${this.ollamaHost}/api/chat`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: 'llama3', // Must run: ollama pull llama3
        messages: [
          { role: 'system', content: `You are a helpful book assistant. Use ONLY the following context to answer: ${context}` },
          { role: 'user', content: prompt }
        ],
        stream: false, 
      }),
    });
    const data = await response.json();
    return data.message.content;
  }
}
</file>

<file path="src/ai/rag.service.ts">
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { OllamaService } from './ollama.service';

@Injectable()
export class RagService {
  constructor(
    private prisma: PrismaService,
    private ollamaService: OllamaService,
  ) {}

  async askQuestion(bookId: string, question: string) {
    // 1. Embed Question
    const questionEmbedding = await this.ollamaService.generateEmbedding(question);

    // 2. Vector Search (Find relevant chunks)
    // We cast the result to any[] because Prisma types for raw queries are loose
    const relevantChunks: any[] = await this.prisma.$queryRaw`
      SELECT content 
      FROM "book_chunks"
      WHERE "uploaded_book_id" = ${bookId}
      ORDER BY embedding <-> ${questionEmbedding}::vector
      LIMIT 5
    `;

    const context = relevantChunks.map(c => c.content).join("\n---\n");

    // 3. Generate Answer
    const answer = await this.ollamaService.chat(question, context);
    
    return { answer, contextUsed: relevantChunks.length };
  }
}
</file>

<file path="src/auth/supabase.strategy.ts">
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class SupabaseStrategy extends PassportStrategy(Strategy) {
  constructor(private readonly configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get<string>('SUPABASE_JWT_SECRET'),
    });
  }

  async validate(payload: any) {
    if (!payload || !payload.sub) {
      throw new UnauthorizedException();
    }
    // Returns the user object attached to the request
    return { userId: payload.sub, email: payload.email };
  }
}
</file>

<file path="src/books/books.controller.ts">
import { Controller, Get, Query, Param, BadRequestException } from '@nestjs/common';
import { BooksService } from './books.service';

@Controller('books')
export class BooksController {
  constructor(private readonly booksService: BooksService) {}

  // Endpoint: GET /books/search?q=Harry+Potter
  // Public access: Anyone can search for books
  @Get('search')
  async search(@Query('q') query: string) {
    if (!query) {
      throw new BadRequestException('Search query is required');
    }
    return this.booksService.search(query);
  }

  // Endpoint: GET /books/:id
  // Usage: The frontend passes the Google Book ID (e.g. "wrOQLV6xB-wC")
  // Public access: Anyone can view book details
  @Get(':id')
  async getBookDetails(@Param('id') googleBookId: string) {
    return this.booksService.getBookDetails(googleBookId);
  }
}
</file>

<file path="src/books/books.service.ts">
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { HttpService } from '@nestjs/axios';
import { firstValueFrom } from 'rxjs';

@Injectable()
export class BooksService {
  constructor(
    private prisma: PrismaService,
    private httpService: HttpService,
  ) {}

  // 1. Search Google Books API
  async search(query: string) {
    const apiKey = process.env.GOOGLE_BOOKS_API_KEY; // Optional, works without it for low volume
    const url = `https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(query)}&key=${apiKey || ''}`;
    
    const { data } = await firstValueFrom(this.httpService.get(url));
    
    // Map to our format
    return data.items.map((item: any) => ({
      googleBookId: item.id,
      title: item.volumeInfo.title,
      author: item.volumeInfo.authors?.[0] || 'Unknown',
      coverUrl: item.volumeInfo.imageLinks?.thumbnail?.replace('http:', 'https:'),
      publishedYear: item.volumeInfo.publishedDate?.substring(0, 4),
    }));
  }

  // 2. Get Book Details (Checks DB first, then Google)
  async getBookDetails(googleBookId: string) {
    // Check cache
    const existing = await this.prisma.book.findUnique({ where: { googleBookId } });
    if (existing) return existing;

    // Fetch and Cache
    const url = `https://www.googleapis.com/books/v1/volumes/${googleBookId}`;
    const { data } = await firstValueFrom(this.httpService.get(url));
    const info = data.volumeInfo;

    return this.prisma.book.create({
      data: {
        googleBookId: data.id,
        title: info.title,
        author: info.authors?.[0] || 'Unknown',
        description: info.description, // HTML description
        coverUrl: info.imageLinks?.thumbnail?.replace('http:', 'https:'),
        pageCount: info.pageCount || 0,
        publishedYear: parseInt(info.publishedDate?.substring(0, 4)) || null,
        genres: info.categories || [],
      },
    });
  }
}
</file>

<file path="src/bookshelf/bookshelf.controller.ts">
import { Controller, Get, Post, Body, UseGuards, Request } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { BookshelfService } from './bookshelf.service';
import { ShelfStatus } from '@prisma/client';

@Controller('bookshelf')
@UseGuards(AuthGuard('jwt'))
export class BookshelfController {
  constructor(private readonly bookshelfService: BookshelfService) {}

  @Get()
  getMyShelf(@Request() req) {
    return this.bookshelfService.getMyBookshelf(req.user.userId);
  }

  @Post()
  addItem(@Request() req, @Body() body: { bookId: string; status: ShelfStatus }) {
    return this.bookshelfService.addBook(req.user.userId, body.bookId, body.status);
  }
}
</file>

<file path="src/bookshelf/bookshelf.module.ts">
import { Module } from '@nestjs/common';
import { BookshelfService } from './bookshelf.service';
import { BookshelfController } from './bookshelf.controller';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [BookshelfController],
  providers: [BookshelfService],
})
export class BookshelfModule {}
</file>

<file path="src/bookshelf/bookshelf.service.ts">
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { ShelfStatus } from '@prisma/client';

@Injectable()
export class BookshelfService {
  constructor(private prisma: PrismaService) {}

  async getMyBookshelf(userId: string) {
    return this.prisma.bookshelfItem.findMany({
      where: { profile: { userId } },
      include: { book: true },
      orderBy: { updatedAt: 'desc' },
    });
  }

  async addBook(userId: string, bookId: string, status: ShelfStatus) {
    const profile = await this.prisma.profile.findUnique({ where: { userId } });
    
    return this.prisma.bookshelfItem.upsert({
      where: {
        profileId_bookId: {
          profileId: profile?.id!,
          bookId,
        },
      },
      update: { status, updatedAt: new Date() },
      create: {
        profileId: profile?.id!,
        bookId,
        status,
      },
    });
  }
}
</file>

<file path="src/ingestion/dto/create-ingestion.dto.ts">
export class CreateIngestionDto {}
</file>

<file path="src/ingestion/dto/update-ingestion.dto.ts">
import { PartialType } from '@nestjs/mapped-types';
import { CreateIngestionDto } from './create-ingestion.dto';

export class UpdateIngestionDto extends PartialType(CreateIngestionDto) {}
</file>

<file path="src/ingestion/entities/ingestion.entity.ts">
export class Ingestion {}
</file>

<file path="src/ingestion/ingestion.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { IngestionController } from './ingestion.controller';
import { IngestionService } from './ingestion.service';

describe('IngestionController', () => {
  let controller: IngestionController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [IngestionController],
      providers: [IngestionService],
    }).compile();

    controller = module.get<IngestionController>(IngestionController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/ingestion/ingestion.controller.ts">
import { Controller, Post, UploadedFile, UseInterceptors, UseGuards, Request } from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { AuthGuard } from '@nestjs/passport'; // The guard we made
import { IngestionService } from './ingestion.service';
import { PrismaService } from '../prisma/prisma.service';

@Controller('ingestion')
export class IngestionController {
  constructor(
    private ingestionService: IngestionService,
    private prisma: PrismaService
  ) {}

  @Post('upload')
  @UseGuards(AuthGuard('jwt'))
  @UseInterceptors(FileInterceptor('file'))
  async uploadPdf(@UploadedFile() file: Express.Multer.File, @Request() req) {
    // 1. Get Profile ID from User ID
    const profile = await this.prisma.profile.findUnique({
      where: { userId: req.user.userId }
    });
    
    // 2. Process
    return this.ingestionService.processFile(profile?.id!, file.buffer, file.originalname);
  }
}
</file>

<file path="src/ingestion/ingestion.module.ts">
import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bullmq';
import { IngestionController } from './ingestion.controller';
import { IngestionProcessor } from './ingestion.processor';
import { IngestionService } from './ingestion.service'; // <--- 1. Import this
import { AiModule } from '../ai/ai.module';

@Module({
  imports: [
    BullModule.registerQueue({
      name: 'ingestion-queue',
    }),
    AiModule,
  ],
  controllers: [IngestionController],
  // 2. Add IngestionService to the providers array below
  providers: [IngestionService, IngestionProcessor], 
})
export class IngestionModule {}
</file>

<file path="src/ingestion/ingestion.processor.ts">
import { Processor, WorkerHost } from '@nestjs/bullmq';
import { Job } from 'bullmq';
import { IngestionService } from './ingestion.service';
import { Logger } from '@nestjs/common';

@Processor('ingestion-queue')
export class IngestionProcessor extends WorkerHost {
  private readonly logger = new Logger(IngestionProcessor.name);

  constructor(private readonly ingestionService: IngestionService) {
    super();
  }

  async process(job: Job<any, any, string>): Promise<any> {
    switch (job.name) {
      case 'process-pdf':
        this.logger.log(`Processing job ${job.id}: Analyzing PDF for book ${job.data.bookId}...`);
        
        try {
          // 1. Reconstruct Buffer from Base64 (queues store data as JSON strings)
          const fileBuffer = Buffer.from(job.data.fileBuffer, 'base64');
          
          // 2. Call the service to Parse -> Chunk -> Embed
          const result = await this.ingestionService.processFile(
            job.data.userId, // We used profileId in the service, but let's pass what we have
            fileBuffer,
            `Book-${job.data.bookId}` // Using generic name or title passed in job
          );

          this.logger.log(`Job ${job.id} completed! ${result.chunksProcessed} chunks created.`);
          return result;

        } catch (error) {
          this.logger.error(`Job ${job.id} failed`, error);
          throw error;
        }
        
      default:
        throw new Error(`Unknown job name: ${job.name}`);
    }
  }
}
</file>

<file path="src/ingestion/ingestion.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { IngestionService } from './ingestion.service';

describe('IngestionService', () => {
  let service: IngestionService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [IngestionService],
    }).compile();

    service = module.get<IngestionService>(IngestionService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/ingestion/ingestion.service.ts">
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { OllamaService } from '../ai/ollama.service';
import { RecursiveCharacterTextSplitter } from '@langchain/textsplitters'; // Fixed import

// Use this specific syntax to match the "export = PDFParse" in our d.ts file
import pdf = require('pdf-parse'); 

@Injectable()
export class IngestionService {
  constructor(
    private prisma: PrismaService,
    private ollamaService: OllamaService,
  ) {}

  async processFile(profileId: string, fileBuffer: Buffer, filename: string) {
    // 1. Create Upload Record
    const uploadedBook = await this.prisma.uploadedBook.create({
      data: {
        profileId,
        title: filename,
        filePath: `uploads/${filename}`, // Mock path for this stage
        status: 'PROCESSING',
      },
    });

    try {
      // 2. Parse PDF
      // Now TypeScript knows 'pdf' is a function that returns a Promise
      const pdfData = await pdf(fileBuffer);
      const fullText = pdfData.text;

      // 3. Chunking
      const splitter = new RecursiveCharacterTextSplitter({
        chunkSize: 1000,
        chunkOverlap: 200,
      });
      const chunks = await splitter.createDocuments([fullText]);

      // 4. Embed & Save Loop
      for (const chunk of chunks) {
        // Generate embedding from Ollama
        const embedding = await this.ollamaService.generateEmbedding(chunk.pageContent);
        
        // Save to DB using raw SQL for vector support
        // We cast parameters to ensure PostgreSQL understands the vector type
        await this.prisma.$executeRaw`
          INSERT INTO "book_chunks" (id, "uploaded_book_id", content, embedding, metadata)
          VALUES (
            gen_random_uuid(), 
            ${uploadedBook.id}, 
            ${chunk.pageContent}, 
            ${embedding}::vector, 
            ${JSON.stringify(chunk.metadata)}::jsonb
          )
        `;
      }

      // 5. Update Status to READY
      await this.prisma.uploadedBook.update({
        where: { id: uploadedBook.id },
        data: { status: 'READY' },
      });

      return { success: true, chunksProcessed: chunks.length };

    } catch (error) {
      console.error('Ingestion Error:', error);
      
      // Update Status to ERROR on failure
      await this.prisma.uploadedBook.update({
        where: { id: uploadedBook.id },
        data: { status: 'ERROR' },
      });
      
      throw error;
    }
  }
}
</file>

<file path="src/prisma/dto/create-prisma.dto.ts">
export class CreatePrismaDto {}
</file>

<file path="src/prisma/dto/update-prisma.dto.ts">
import { PartialType } from '@nestjs/mapped-types';
import { CreatePrismaDto } from './create-prisma.dto';

export class UpdatePrismaDto extends PartialType(CreatePrismaDto) {}
</file>

<file path="src/prisma/entities/prisma.entity.ts">
export class Prisma {}
</file>

<file path="src/prisma/prisma.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { PrismaController } from './prisma.controller';
import { PrismaService } from './prisma.service';

describe('PrismaController', () => {
  let controller: PrismaController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [PrismaController],
      providers: [PrismaService],
    }).compile();

    controller = module.get<PrismaController>(PrismaController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/prisma/prisma.controller.ts">
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { PrismaService } from './prisma.service';
import { CreatePrismaDto } from './dto/create-prisma.dto';
import { UpdatePrismaDto } from './dto/update-prisma.dto';

@Controller('prisma')
export class PrismaController {
  constructor(private readonly prismaService: PrismaService) {}
}
</file>

<file path="src/prisma/prisma.module.ts">
import { Global, Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global()
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}
</file>

<file path="src/prisma/prisma.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { PrismaService } from './prisma.service';

describe('PrismaService', () => {
  let service: PrismaService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [PrismaService],
    }).compile();

    service = module.get<PrismaService>(PrismaService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/prisma/prisma.service.ts">
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';
import { Pool } from 'pg';
import { PrismaPg } from '@prisma/adapter-pg';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {
  constructor() {
    // 1. Create a standard PostgreSQL connection pool
    const connectionString = `${process.env.DATABASE_URL}`;
    const pool = new Pool({ connectionString });

    // 2. Create the Prisma Adapter
    const adapter = new PrismaPg(pool);

    // 3. Pass the adapter to the parent constructor
    super({ adapter });
  }

  async onModuleInit() {
    await this.$connect();
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}
</file>

<file path="src/profile/profile.controller.ts">
import { Controller, Get, Put, Body, Param, UseGuards, Request } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { ProfileService } from './profile.service';

@Controller('profile')
export class ProfileController {
  constructor(private readonly profileService: ProfileService) {}

  @UseGuards(AuthGuard('jwt'))
  @Get('me')
  async getMyProfile(@Request() req) {
    return this.profileService.getProfile(req.user.userId);
  }

  @UseGuards(AuthGuard('jwt'))
  @Put('me')
  async updateProfile(@Request() req, @Body() body: any) {
    return this.profileService.updateProfile(req.user.userId, body);
  }

  @Get(':username')
  async getPublicProfile(@Param('username') username: string) {
    return this.profileService.getPublicProfile(username);
  }
}
</file>

<file path="src/profile/profile.module.ts">
import { Module } from '@nestjs/common';
import { ProfileService } from './profile.service';
import { ProfileController } from './profile.controller';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [ProfileController],
  providers: [ProfileService],
})
export class ProfileModule {}
</file>

<file path="src/profile/profile.service.ts">
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class ProfileService {
  constructor(private prisma: PrismaService) {}

  // Get current user's profile
  async getProfile(userId: string) {
    return this.prisma.profile.findUnique({
      where: { userId },
      include: {
        readingGoal: true,
        _count: { select: { following: true, followedBy: true } },
      },
    });
  }

  // Get public profile by username
  async getPublicProfile(username: string) {
    return this.prisma.profile.findUnique({
      where: { username },
      include: {
        readingGoal: true,
        bookshelfItems: {
            where: { status: 'READ' },
            take: 5,
            include: { book: true }
        },
        _count: { select: { following: true, followedBy: true } },
      },
    });
  }

  // Onboarding / Update Profile
  async updateProfile(userId: string, data: any) {
    // Upsert ensures we create it if it doesn't exist
    return this.prisma.profile.upsert({
      where: { userId },
      update: {
        username: data.username,
        fullName: data.fullName,
        bio: data.bio,
        onboarded: true,
      },
      create: {
        userId,
        username: data.username,
        fullName: data.fullName,
        bio: data.bio,
        onboarded: true,
      },
    });
  }
}
</file>

<file path="src/social/social.controller.ts">
import { Controller, Post, Get, Body, Param, UseGuards, Request } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { SocialService } from './social.service';

@Controller('social')
@UseGuards(AuthGuard('jwt'))
export class SocialController {
  constructor(private readonly socialService: SocialService) {}

  @Post('review')
  createReview(@Request() req, @Body() body: any) {
    return this.socialService.createReview(req.user.userId, body);
  }

  @Post('follow/:username')
  followUser(@Request() req, @Param('username') username: string) {
    return this.socialService.followUser(req.user.userId, username);
  }

  @Get('feed')
  getFeed(@Request() req) {
    return this.socialService.getFeed(req.user.userId);
  }
}
</file>

<file path="src/social/social.module.ts">
import { Module } from '@nestjs/common';
import { SocialService } from './social.service';
import { SocialController } from './social.controller';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [SocialController],
  providers: [SocialService],
})
export class SocialModule {}
</file>

<file path="src/social/social.service.ts">
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class SocialService {
  constructor(private prisma: PrismaService) {}

  async createReview(userId: string, data: any) {
    const profile = await this.prisma.profile.findUnique({ where: { userId } });

    return this.prisma.review.create({
      data: {
        profileId: profile?.id!,
        bookId: data.bookId,
        rating: data.rating,
        content: data.content,
      },
    });
  }

  // Follow a user
  async followUser(followerUserId: string, targetUsername: string) {
    const follower = await this.prisma.profile.findUnique({ where: { userId: followerUserId } });
    const target = await this.prisma.profile.findUnique({ where: { username: targetUsername } });

    return this.prisma.userFollow.create({
      data: {
        followerId: follower?.id!,
        followingId: target?.id!,
      },
    });
  }

  // Get Feed (Reviews from people you follow)
  async getFeed(userId: string) {
    const profile = await this.prisma.profile.findUnique({ where: { userId } });

    return this.prisma.review.findMany({
      where: {
        profile: {
          followedBy: {
            some: { followerId: profile?.id! }
          }
        }
      },
      include: {
        book: true,
        profile: { select: { username: true, avatarUrl: true } }
      },
      orderBy: { createdAt: 'desc' },
    });
  }
}
</file>

<file path="src/tracker/tracker.controller.ts">
import { Controller, Post, Get, Body, UseGuards, Request } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { TrackerService } from './tracker.service';

@Controller('tracker')
@UseGuards(AuthGuard('jwt'))
export class TrackerController {
  constructor(private readonly trackerService: TrackerService) {}

  @Post('log')
  logSession(@Request() req, @Body() body: any) {
    return this.trackerService.logSession(req.user.userId, body);
  }

  @Get('stats')
  getStats(@Request() req) {
    return this.trackerService.getStats(req.user.userId);
  }
}
</file>

<file path="src/tracker/tracker.module.ts">
import { Module } from '@nestjs/common';
import { TrackerService } from './tracker.service';
import { TrackerController } from './tracker.controller';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [TrackerController],
  providers: [TrackerService],
})
export class TrackerModule {}
</file>

<file path="src/tracker/tracker.service.ts">
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class TrackerService {
  constructor(private prisma: PrismaService) {}

  async logSession(userId: string, data: any) {
    const profile = await this.prisma.profile.findUnique({ where: { userId } });

    // 1. Create Session
    const session = await this.prisma.readingSession.create({
      data: {
        profileId: profile?.id!,
        bookId: data.bookId,
        startTime: new Date(data.startTime),
        endTime: new Date(data.endTime),
        durationMin: data.durationMin,
        pagesRead: data.pagesRead,
      },
    });

    // 2. Update Bookshelf Progress
    await this.prisma.bookshelfItem.update({
      where: {
        profileId_bookId: { profileId: profile?.id!, bookId: data.bookId },
      },
      data: {
        progress: data.endPage,
        status: 'READING',
      },
    });

    return session;
  }

  async getStats(userId: string) {
    const profile = await this.prisma.profile.findUnique({ where: { userId } });
    
    // Aggregations
    const totalBooks = await this.prisma.bookshelfItem.count({
        where: { profileId: profile?.id!, status: 'READ' }
    });

    const totalPages = await this.prisma.readingSession.aggregate({
        where: { profileId: profile?.id! },
        _sum: { pagesRead: true, durationMin: true }
    });

    return {
        booksRead: totalBooks,
        pagesRead: totalPages._sum.pagesRead || 0,
        minutesRead: totalPages._sum.durationMin || 0,
    };
  }
}
</file>

<file path="src/types/pdf-parse.d.ts">
declare module 'pdf-parse' {
    function PDFParse(dataBuffer: Buffer, options?: any): Promise<{
        numpages: number;
        numrender: number;
        info: any;
        metadata: any;
        text: string;
        version: string;
    }>;
    export = PDFParse;
}
</file>

<file path="eslint.config.mjs">
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      sourceType: 'commonjs',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'warn',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      "prettier/prettier": ["error", { endOfLine: "auto" }],
    },
  },
);
</file>

<file path="prisma.config.ts">
import { defineConfig } from '@prisma/config';
import 'dotenv/config';

export default defineConfig({
  datasource: {
    url: process.env.DATABASE_URL!,
  },
});
</file>

<file path="repomix-output1.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
prisma/
  schema.prisma
src/
  ai/
    dto/
      create-ai.dto.ts
      update-ai.dto.ts
    entities/
      ai.entity.ts
    ai.controller.spec.ts
    ai.controller.ts
    ai.module.ts
    ai.service.spec.ts
    ollama.service.ts
  ingestion/
    dto/
      create-ingestion.dto.ts
      update-ingestion.dto.ts
    entities/
      ingestion.entity.ts
    ingestion.controller.spec.ts
    ingestion.controller.ts
    ingestion.module.ts
    ingestion.service.spec.ts
    ingestion.service.ts
  prisma/
    dto/
      create-prisma.dto.ts
      update-prisma.dto.ts
    entities/
      prisma.entity.ts
    prisma.controller.spec.ts
    prisma.controller.ts
    prisma.module.ts
    prisma.service.spec.ts
    prisma.service.ts
  app.controller.spec.ts
  app.controller.ts
  app.module.ts
  app.service.ts
  main.ts
test/
  app.e2e-spec.ts
  jest-e2e.json
.gitignore
.prettierrc
eslint.config.mjs
nest-cli.json
package.json
prisma.config.ts
README.md
tsconfig.build.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="prisma/schema.prisma">
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  extensions = [vector]
}

// --- Module A: Social Platform Models ---

model Profile {
  id          String   @id @default(uuid())
  userId      String   @unique @map("user_id") // References auth.users.id
  username    String   @unique
  fullName    String?  @map("full_name")
  bio         String?
  avatarUrl   String?  @map("avatar_url")
  onboarded   Boolean  @default(false)
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  readingGoal    ReadingGoal?
  achievements   UserAchievement[]
  bookshelfItems BookshelfItem[]
  customShelves  CustomShelf[]
  sessions       ReadingSession[]
  reviews        Review[]
  sentMessages   ChatMessage[]     @relation("sentMessages")
  receivedMessages ChatMessage[]   @relation("receivedMessages")
  
  // Follow System
  followedBy UserFollow[] @relation("following")
  following  UserFollow[] @relation("follower")

  // AI Module
  uploadedBooks UploadedBook[]

  @@map("profiles")
}

model ReadingGoal {
  id        Int       @id @default(autoincrement())
  profileId String    @unique @map("profile_id")
  type      String    // 'BOOKS_PER_YEAR', 'MINUTES_PER_DAY'
  value     Int
  startDate DateTime  @default(now()) @map("start_date")
  endDate   DateTime? @map("end_date")

  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@map("reading_goals")
}

model UserAchievement {
  profileId     String   @map("profile_id")
  achievementId Int      @map("achievement_id")
  earnedAt      DateTime @default(now()) @map("earned_at")

  profile     Profile     @relation(fields: [profileId], references: [id], onDelete: Cascade)
  achievement Achievement @relation(fields: [achievementId], references: [id])

  @@id([profileId, achievementId])
  @@map("user_achievements")
}

model Achievement {
  id          Int     @id @default(autoincrement())
  name        String
  description String?
  iconUrl     String? @map("icon_url")

  users UserAchievement[]

  @@map("achievements")
}

// --- Book Catalogue & Shelves ---

model Book {
  id            String   @id @default(cuid())
  googleBookId  String   @unique @map("google_book_id")
  title         String
  author        String
  synopsis      String?
  coverUrl      String?  @map("cover_url")
  isbn          String?
  pageCount     Int      @default(0) @map("page_count")
  publishedYear Int?     @map("published_year")
  genres        String[]
  
  // Relations
  shelvedBy BookshelfItem[]
  reviews   Review[]
  sessions  ReadingSession[]

  @@map("books")
}

enum ShelfStatus {
  WANT_TO_READ
  READING
  READ
}

model BookshelfItem {
  id        String      @id @default(cuid())
  profileId String      @map("profile_id")
  bookId    String      @map("book_id")
  status    ShelfStatus
  progress  Int         @default(0) // Current page
  rating    Int?        // 1-5 personal rating
  notes     String?
  addedAt   DateTime    @default(now()) @map("added_at")
  startedAt DateTime?   @map("started_at")
  finishedAt DateTime?  @map("finished_at")

  profile      Profile       @relation(fields: [profileId], references: [id], onDelete: Cascade)
  book         Book          @relation(fields: [bookId], references: [id])
  customShelves CustomShelfItem[]

  @@unique([profileId, bookId])
  @@map("bookshelf_items")
}

model CustomShelf {
  id        Int    @id @default(autoincrement())
  profileId String @map("profile_id")
  name      String

  profile Profile           @relation(fields: [profileId], references: [id], onDelete: Cascade)
  items   CustomShelfItem[]

  @@map("custom_shelves")
}

model CustomShelfItem {
  shelfId         Int    @map("shelf_id")
  bookshelfItemId String @map("bookshelf_item_id")

  shelf         CustomShelf   @relation(fields: [shelfId], references: [id], onDelete: Cascade)
  bookshelfItem BookshelfItem @relation(fields: [bookshelfItemId], references: [id], onDelete: Cascade)

  @@id([shelfId, bookshelfItemId])
  @@map("custom_shelf_items")
}

// --- Tracker & Social ---

model ReadingSession {
  id          String   @id @default(cuid())
  profileId   String   @map("profile_id")
  bookId      String   @map("book_id")
  startTime   DateTime @map("start_time")
  endTime     DateTime @map("end_time")
  durationMin Int      @map("duration_minutes")
  startPage   Int      @map("start_page")
  endPage     Int      @map("end_page")
  pagesRead   Int      @map("pages_read")
  notes       String?

  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  book    Book    @relation(fields: [bookId], references: [id])

  @@map("reading_sessions")
}

model Review {
  id        String   @id @default(cuid())
  profileId String   @map("profile_id")
  bookId    String   @map("book_id")
  rating    Int
  content   String?
  likes     Int      @default(0)
  createdAt DateTime @default(now()) @map("created_at")

  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  book    Book    @relation(fields: [bookId], references: [id])

  @@map("reviews")
}

model UserFollow {
  followerId  String @map("follower_id")
  followingId String @map("following_id")

  follower  Profile @relation("follower", fields: [followerId], references: [id])
  following Profile @relation("following", fields: [followingId], references: [id])

  @@id([followerId, followingId])
  @@map("user_follows")
}

model ChatMessage {
  id          String   @id @default(cuid())
  senderId    String   @map("sender_id")
  recipientId String   @map("recipient_id")
  content     String
  isRead      Boolean  @default(false) @map("is_read")
  createdAt   DateTime @default(now()) @map("created_at")

  sender    Profile @relation("sentMessages", fields: [senderId], references: [id])
  recipient Profile @relation("receivedMessages", fields: [recipientId], references: [id])

  @@map("chat_messages")
}

// --- Module B: AI Engine Models ---

model UploadedBook {
  id        String   @id @default(cuid())
  profileId String   @map("profile_id")
  filePath  String   @map("file_path") // Supabase Storage path
  title     String
  status    String   @default("PENDING") // PENDING, PROCESSING, READY, ERROR
  createdAt DateTime @default(now()) @map("created_at")

  profile Profile     @relation(fields: [profileId], references: [id], onDelete: Cascade)
  chunks  BookChunk[]

  @@map("uploaded_books")
}

model BookChunk {
  id             String                 @id @default(cuid())
  uploadedBookId String                 @map("uploaded_book_id")
  content        String
  metadata       Json?                  // Page number, chapter, etc.
  
  // This field requires the `vector` extension in PostgreSQL
  // We use Unsupported type for Prisma, but raw SQL queries will work
  embedding      Unsupported("vector(384)")? 

  uploadedBook UploadedBook @relation(fields: [uploadedBookId], references: [id], onDelete: Cascade)

  @@map("book_chunks")
}
</file>

<file path="src/ai/dto/create-ai.dto.ts">
export class CreateAiDto {}
</file>

<file path="src/ai/dto/update-ai.dto.ts">
import { PartialType } from '@nestjs/mapped-types';
import { CreateAiDto } from './create-ai.dto';

export class UpdateAiDto extends PartialType(CreateAiDto) {}
</file>

<file path="src/ai/entities/ai.entity.ts">
export class Ai {}
</file>

<file path="src/ai/ai.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { AiController } from './ai.controller';
import { AiService } from './ollama.service';

describe('AiController', () => {
  let controller: AiController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AiController],
      providers: [AiService],
    }).compile();

    controller = module.get<AiController>(AiController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/ai/ai.controller.ts">
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { AiService } from './ollama.service';
import { CreateAiDto } from './dto/create-ai.dto';
import { UpdateAiDto } from './dto/update-ai.dto';

@Controller('ai')
export class AiController {
  constructor(private readonly aiService: AiService) {}

  @Post()
  create(@Body() createAiDto: CreateAiDto) {
    return this.aiService.create(createAiDto);
  }

  @Get()
  findAll() {
    return this.aiService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.aiService.findOne(+id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateAiDto: UpdateAiDto) {
    return this.aiService.update(+id, updateAiDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.aiService.remove(+id);
  }
}
</file>

<file path="src/ai/ai.module.ts">
import { Module } from '@nestjs/common';
import { OllamaService } from './ollama.service';

@Module({
  providers: [OllamaService],
  exports: [OllamaService], // Export so IngestionProcessor can use it
})
export class AiModule {}
</file>

<file path="src/ai/ai.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { AiService } from './ollama.service';

describe('AiService', () => {
  let service: AiService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [AiService],
    }).compile();

    service = module.get<AiService>(AiService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/ai/ollama.service.ts">
import { Injectable, InternalServerErrorException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class OllamaService {
  private ollamaHost: string;

  constructor(private config: ConfigService) {
    this.ollamaHost = this.config.get('OLLAMA_HOST') || 'http://127.0.0.1:11434';
  }

  async generateEmbedding(text: string): Promise<number[]> {
    try {
      const response = await fetch(`${this.ollamaHost}/api/embeddings`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model: 'all-minilm', // Ensure you have run `ollama pull all-minilm`
          prompt: text,
        }),
      });

      if (!response.ok) {
        throw new Error(`Ollama Error: ${response.statusText}`);
      }

      const data = await response.json();
      return data.embedding;
    } catch (error) {
      console.error('Embedding failed:', error);
      throw new InternalServerErrorException('Failed to generate embedding');
    }
  }

  async generateSummary(text: string): Promise<string> {
    // Basic chat call for summarization
    const response = await fetch(`${this.ollamaHost}/api/generate`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: 'llama3', // Ensure `ollama pull llama3`
        prompt: `Summarize the following text in 3 sentences:\n\n${text}`,
        stream: false,
      }),
    });

    const data = await response.json();
    return data.response;
  }
}
</file>

<file path="src/ingestion/dto/create-ingestion.dto.ts">
export class CreateIngestionDto {}
</file>

<file path="src/ingestion/dto/update-ingestion.dto.ts">
import { PartialType } from '@nestjs/mapped-types';
import { CreateIngestionDto } from './create-ingestion.dto';

export class UpdateIngestionDto extends PartialType(CreateIngestionDto) {}
</file>

<file path="src/ingestion/entities/ingestion.entity.ts">
export class Ingestion {}
</file>

<file path="src/ingestion/ingestion.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { IngestionController } from './ingestion.controller';
import { IngestionService } from './ingestion.service';

describe('IngestionController', () => {
  let controller: IngestionController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [IngestionController],
      providers: [IngestionService],
    }).compile();

    controller = module.get<IngestionController>(IngestionController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/ingestion/ingestion.controller.ts">
import { Controller, Post, UploadedFile, UseInterceptors, Body } from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { InjectQueue } from '@nestjs/bullmq';
import { Queue } from 'bullmq';

@Controller('ingestion')
export class IngestionController {
  constructor(@InjectQueue('ingestion-queue') private ingestionQueue: Queue) {}

  @Post('upload')
  @UseInterceptors(FileInterceptor('file'))
  async uploadFile(
    @UploadedFile() file: Express.Multer.File,
    @Body('bookId') bookId: string,
    @Body('userId') userId: string
  ) {
    // In a real app, you'd upload 'file.buffer' to Supabase Storage here.
    // For this prototype, we'll pass the buffer directly to the queue (careful with size limits!)
    // or simulate that the file is available at a URL.
    
    // Adding job to the queue
    await this.ingestionQueue.add('process-pdf', {
      bookId,
      userId,
      fileBuffer: file.buffer.toString('base64'), // Encoding for transport
      mimeType: file.mimetype,
    });

    return { status: 'queued', message: 'Book is being processed in the background.' };
  }
}
</file>

<file path="src/ingestion/ingestion.module.ts">
import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bullmq';
import { IngestionController } from './ingestion.controller';
import { IngestionProcessor } from './ingestion.processor';
import { AiModule } from '../ai/ai.module';

@Module({
  imports: [
    BullModule.registerQueue({
      name: 'ingestion-queue',
    }),
    AiModule, // Import AI Module to access OllamaService
  ],
  controllers: [IngestionController],
  providers: [IngestionProcessor],
})
export class IngestionModule {}
</file>

<file path="src/ingestion/ingestion.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { IngestionService } from './ingestion.service';

describe('IngestionService', () => {
  let service: IngestionService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [IngestionService],
    }).compile();

    service = module.get<IngestionService>(IngestionService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/ingestion/ingestion.service.ts">
import { Injectable } from '@nestjs/common';
import { CreateIngestionDto } from './dto/create-ingestion.dto';
import { UpdateIngestionDto } from './dto/update-ingestion.dto';

@Injectable()
export class IngestionService {
  create(createIngestionDto: CreateIngestionDto) {
    return 'This action adds a new ingestion';
  }

  findAll() {
    return `This action returns all ingestion`;
  }

  findOne(id: number) {
    return `This action returns a #${id} ingestion`;
  }

  update(id: number, updateIngestionDto: UpdateIngestionDto) {
    return `This action updates a #${id} ingestion`;
  }

  remove(id: number) {
    return `This action removes a #${id} ingestion`;
  }
}
</file>

<file path="src/prisma/dto/create-prisma.dto.ts">
export class CreatePrismaDto {}
</file>

<file path="src/prisma/dto/update-prisma.dto.ts">
import { PartialType } from '@nestjs/mapped-types';
import { CreatePrismaDto } from './create-prisma.dto';

export class UpdatePrismaDto extends PartialType(CreatePrismaDto) {}
</file>

<file path="src/prisma/entities/prisma.entity.ts">
export class Prisma {}
</file>

<file path="src/prisma/prisma.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { PrismaController } from './prisma.controller';
import { PrismaService } from './prisma.service';

describe('PrismaController', () => {
  let controller: PrismaController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [PrismaController],
      providers: [PrismaService],
    }).compile();

    controller = module.get<PrismaController>(PrismaController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/prisma/prisma.controller.ts">
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { PrismaService } from './prisma.service';
import { CreatePrismaDto } from './dto/create-prisma.dto';
import { UpdatePrismaDto } from './dto/update-prisma.dto';

@Controller('prisma')
export class PrismaController {
  constructor(private readonly prismaService: PrismaService) {}

  @Post()
  create(@Body() createPrismaDto: CreatePrismaDto) {
    return this.prismaService.create(createPrismaDto);
  }

  @Get()
  findAll() {
    return this.prismaService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.prismaService.findOne(+id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updatePrismaDto: UpdatePrismaDto) {
    return this.prismaService.update(+id, updatePrismaDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.prismaService.remove(+id);
  }
}
</file>

<file path="src/prisma/prisma.module.ts">
import { Global, Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global()
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}
</file>

<file path="src/prisma/prisma.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { PrismaService } from './prisma.service';

describe('PrismaService', () => {
  let service: PrismaService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [PrismaService],
    }).compile();

    service = module.get<PrismaService>(PrismaService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/prisma/prisma.service.ts">
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {
  async onModuleInit() {
    await this.$connect();
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}
</file>

<file path="eslint.config.mjs">
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      sourceType: 'commonjs',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'warn',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      "prettier/prettier": ["error", { endOfLine: "auto" }],
    },
  },
);
</file>

<file path="prisma.config.ts">
import { defineConfig } from '@prisma/config';

export default defineConfig({
  datasource: {
    url: process.env.DATABASE_URL!,
  },
});
</file>

<file path="src/app.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});
</file>

<file path="src/app.controller.ts">
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}
</file>

<file path="test/app.e2e-spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import request from 'supertest';
import { App } from 'supertest/types';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication<App>;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});
</file>

<file path="test/jest-e2e.json">
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}
</file>

<file path=".gitignore">
# compiled output
/dist
/node_modules
/build

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# temp directory
.temp
.tmp

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json
</file>

<file path=".prettierrc">
{
  "singleQuote": true,
  "trailingComma": "all"
}
</file>

<file path="nest-cli.json">
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}
</file>

<file path="README.md">
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ npm install
```

## Compile and run the project

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Run tests

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Deployment

When you're ready to deploy your NestJS application to production, there are some key steps you can take to ensure it runs as efficiently as possible. Check out the [deployment documentation](https://docs.nestjs.com/deployment) for more information.

If you are looking for a cloud-based platform to deploy your NestJS application, check out [Mau](https://mau.nestjs.com), our official platform for deploying NestJS applications on AWS. Mau makes deployment straightforward and fast, requiring just a few simple steps:

```bash
$ npm install -g @nestjs/mau
$ mau deploy
```

With Mau, you can deploy your application in just a few clicks, allowing you to focus on building features rather than managing infrastructure.

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Deploy your application to AWS with the help of [NestJS Mau](https://mau.nestjs.com) in just a few clicks.
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myliwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).
</file>

<file path="tsconfig.build.json">
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "module": "nodenext",
    "moduleResolution": "nodenext",
    "resolvePackageJsonExports": true,
    "esModuleInterop": true,
    "isolatedModules": true,
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2023",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "noFallthroughCasesInSwitch": false
  }
}
</file>

<file path="src/app.module.ts">
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { PrismaModule } from './prisma/prisma.module';
import { AiModule } from './ai/ai.module';
import { IngestionModule } from './ingestion/ingestion.module';

@Module({
  imports: [PrismaModule, AiModule, IngestionModule],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
</file>

<file path="src/app.service.ts">
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}
</file>

<file path="src/main.ts">
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();
</file>

<file path="package.json">
{
  "name": "read-social-network-be",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json"
  },
  "dependencies": {
    "@nestjs/common": "^11.0.1",
    "@nestjs/core": "^11.0.1",
    "@nestjs/mapped-types": "*",
    "@nestjs/platform-express": "^11.0.1",
    "@prisma/client": "^7.0.0",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.18.0",
    "@nestjs/cli": "^11.0.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.1",
    "@types/express": "^5.0.0",
    "@types/jest": "^30.0.0",
    "@types/node": "^22.10.7",
    "@types/supertest": "^6.0.2",
    "eslint": "^9.18.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-prettier": "^5.2.2",
    "globals": "^16.0.0",
    "jest": "^30.0.0",
    "prettier": "^3.4.2",
    "prisma": "^7.0.0",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.2",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.20.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}
</file>

</files>
</file>

<file path="src/auth/auth.module.ts">
import { Module } from '@nestjs/common';
import { PassportModule } from '@nestjs/passport';
import { SupabaseStrategy } from './supabase.strategy';
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [PassportModule, ConfigModule],
  providers: [SupabaseStrategy],
  exports: [PassportModule, SupabaseStrategy],
})
export class AuthModule {}
</file>

<file path="src/app.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});
</file>

<file path="src/app.controller.ts">
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}
</file>

<file path="test/app.e2e-spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import request from 'supertest';
import { App } from 'supertest/types';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication<App>;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});
</file>

<file path="test/jest-e2e.json">
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}
</file>

<file path=".gitignore">
# compiled output
/dist
/node_modules
/build

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# temp directory
.temp
.tmp

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json
</file>

<file path=".prettierrc">
{
  "singleQuote": true,
  "trailingComma": "all"
}
</file>

<file path="nest-cli.json">
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}
</file>

<file path="README.md">
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ npm install
```

## Compile and run the project

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Run tests

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Deployment

When you're ready to deploy your NestJS application to production, there are some key steps you can take to ensure it runs as efficiently as possible. Check out the [deployment documentation](https://docs.nestjs.com/deployment) for more information.

If you are looking for a cloud-based platform to deploy your NestJS application, check out [Mau](https://mau.nestjs.com), our official platform for deploying NestJS applications on AWS. Mau makes deployment straightforward and fast, requiring just a few simple steps:

```bash
$ npm install -g @nestjs/mau
$ mau deploy
```

With Mau, you can deploy your application in just a few clicks, allowing you to focus on building features rather than managing infrastructure.

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Deploy your application to AWS with the help of [NestJS Mau](https://mau.nestjs.com) in just a few clicks.
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myliwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).
</file>

<file path="tsconfig.build.json">
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "module": "nodenext",
    "moduleResolution": "nodenext",
    "resolvePackageJsonExports": true,
    "esModuleInterop": true,
    "isolatedModules": true,
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2023",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "noFallthroughCasesInSwitch": false,
    "types": ["node", "jest", "express", "multer"]
  },
  "include": ["src/**/*", "src/types/**/*.d.ts"]
}
</file>

<file path="src/app.module.ts">
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { HttpModule } from '@nestjs/axios';
import { BullModule } from '@nestjs/bullmq'; // <--- Import this

// Core Modules
import { AuthModule } from './auth/auth.module';
import { PrismaModule } from './prisma/prisma.module';
import { AiModule } from './ai/ai.module';
import { IngestionModule } from './ingestion/ingestion.module';

// Feature Modules
import { ProfileModule } from './profile/profile.module';
import { BookshelfModule } from './bookshelf/bookshelf.module';
import { TrackerModule } from './tracker/tracker.module';
import { SocialModule } from './social/social.module';

// Simple Controllers
import { BooksController } from './books/books.controller';
import { BooksService } from './books/books.service';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [
    ConfigModule.forRoot({ isGlobal: true }),
    HttpModule,
    
    // Add the Root BullMQ Configuration here
    BullModule.forRoot({
      connection: {
        host: process.env.REDIS_HOST || 'localhost',
        port: parseInt(process.env.REDIS_PORT || '6379'),
      },
    }),

    // Infrastructure
    AuthModule,
    PrismaModule,
    
    // AI Engine
    AiModule,
    IngestionModule,
    
    // Application Features
    ProfileModule,
    BookshelfModule,
    TrackerModule,
    SocialModule,
  ],
  controllers: [AppController, BooksController],
  providers: [AppService, BooksService],
})
export class AppModule {}
</file>

<file path="src/app.service.ts">
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}
</file>

<file path="src/main.ts">
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.enableCors({
    origin: 'http://localhost:3001', // Allow your frontend
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    credentials: true, // Allow cookies/headers
  });

  await app.listen(process.env.PORT ?? 3000);
}

bootstrap();
</file>

<file path="package.json">
{
  "name": "read-social-network-be",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json"
  },
  "dependencies": {
    "@langchain/textsplitters": "^1.0.1",
    "@nestjs/axios": "^4.0.1",
    "@nestjs/bullmq": "^11.0.4",
    "@nestjs/common": "^11.0.1",
    "@nestjs/config": "^4.0.2",
    "@nestjs/core": "^11.0.1",
    "@nestjs/mapped-types": "*",
    "@nestjs/passport": "^11.0.5",
    "@nestjs/platform-express": "^11.0.1",
    "@prisma/adapter-pg": "^7.0.1",
    "@prisma/client": "^7.0.1",
    "@supabase/supabase-js": "^2.86.0",
    "bullmq": "^5.65.0",
    "dotenv": "^17.2.3",
    "langchain": "^1.1.1",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "pdf-parse": "^2.4.5",
    "pg": "^8.16.3",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.18.0",
    "@nestjs/cli": "^11.0.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.1",
    "@types/express": "^5.0.0",
    "@types/jest": "^30.0.0",
    "@types/multer": "^2.0.0",
    "@types/node": "^22.10.7",
    "@types/pg": "^8.15.6",
    "@types/supertest": "^6.0.2",
    "eslint": "^9.18.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-prettier": "^5.2.2",
    "globals": "^16.0.0",
    "jest": "^30.0.0",
    "prettier": "^3.4.2",
    "prisma": "^7.0.1",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.2",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.20.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}
</file>

</files>
